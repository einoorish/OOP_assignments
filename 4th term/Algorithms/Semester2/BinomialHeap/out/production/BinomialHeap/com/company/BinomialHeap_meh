package com.company;

class Node {
    int key, degree;
    Node parent;
    Node sibling;
    Node child;

    Node(int k) {
        key = k;
    }

    Node reverse(Node sibling) {
        Node ret;
        if (this.sibling != null) {
            ret = sibling.reverse(this);
        } else {
            ret = this;
        }
        this.sibling = sibling;
        return ret;
    }

    Node getMinNode() {
        Node x = this, y = this;
        int min = x.key;

        while (x != null) {
            if (x.key < min) {
                y = x;
                min = x.key;
            }

            x = x.sibling;
        }

        return y;
    }

    Node getNodeByKey(int value) {
        Node temp = this, node = null;

        while (temp != null) {
            if (temp.key == value) {
                node = temp;
                break;
            }

            if (temp.child == null)
                temp = temp.sibling;
            else {
                node = temp.child.getNodeByKey(value);
                if (node == null)
                    temp = temp.sibling;
                else
                    break;
            }
        }
        return node;
    }

    int getSize(){
        return (1 + ((child == null) ? 0 : child.getSize()) + ((sibling == null) ? 0 : sibling.getSize()));
    }
}


class BinomialHeap {
    private Node nodes;
    private int size;

    public boolean isEmpty(){
        return nodes == null;
    }

    public int getSize(){
        return size;
    }

    public void makeEmpty(){
        nodes = null;
        size = 0;
    }

    public void insert(int value) {
        if (value > 0) {
            Node temp = new Node(value);
            if (nodes == null) {
                nodes = temp;
                size = 1;
            } else {
                unionNodes(temp);
                size++;
            }
        }
    }

    private void merge(Node binHeap) {
        Node temp1 = nodes, temp2 = binHeap;

        while ((temp1 != null) && (temp2 != null)) {
            if (temp1.degree == temp2.degree) {
                Node tmp = temp2;
                temp2 = temp2.sibling;
                tmp.sibling = temp1.sibling;
                temp1.sibling = tmp;
                temp1 = tmp.sibling;
            } else {
                if (temp1.degree < temp2.degree) {
                    if ((temp1.sibling == null) || (temp1.sibling.degree > temp2.degree)) {
                        Node tmp = temp2;
                        temp2 = temp2.sibling;
                        tmp.sibling = temp1.sibling;
                        temp1.sibling = tmp;
                        temp1 = tmp.sibling;
                    } else {
                        temp1 = temp1.sibling;
                    }
                } else {
                    Node tmp = temp1;
                    temp1 = temp2;
                    temp2 = temp2.sibling;
                    temp1.sibling = tmp;
                    if (tmp == nodes) {
                        nodes = temp1;
                    }
                }
            }
        }

        if (temp1 == null) {
            temp1 = nodes;
            while (temp1.sibling != null) {
                temp1 = temp1.sibling;
            }
            temp1.sibling = temp2;
        }
    }

    private void unionNodes(Node binHeap) {
        merge(binHeap);
        Node prevTemp = null, temp = nodes, nextTemp = nodes.sibling;

        while (nextTemp != null) {
            if ((temp.degree != nextTemp.degree) || ((nextTemp.sibling != null) && (nextTemp.sibling.degree == temp.degree))) {
                prevTemp = temp;
                temp = nextTemp;
            } else {
                if (temp.key <= nextTemp.key) {
                    temp.sibling = nextTemp.sibling;
                    nextTemp.parent = temp;
                    nextTemp.sibling = temp.child;
                    temp.child = nextTemp;
                    temp.degree++;
                } else {
                    if (prevTemp == null) {
                        nodes = nextTemp;
                    } else {
                        prevTemp.sibling = nextTemp;
                    }

                    temp.parent = nextTemp;
                    temp.sibling = nextTemp.child;
                    nextTemp.child = temp;
                    nextTemp.degree++;
                    temp = nextTemp;
                }

            }
            nextTemp = temp.sibling;

        }

    }

    public int findMinimum() {
        return nodes.getMinNode().key;
    }

    /* Function to delete a particular element */

    public void delete(int value) {
        if ((nodes != null) && (nodes.getNodeByKey(value) != null)) {
            decreaseKeyValue(value, findMinimum() - 1);
            extractMin();
        }
    }

    public void decreaseKeyValue(int old_value, int new_value) {
        Node temp = nodes.getNodeByKey(old_value);
        if (temp == null)
            return;
        temp.key = new_value;
        Node tempParent = temp.parent;

        while ((tempParent != null) && (temp.key < tempParent.key)) {
            int z = temp.key;
            temp.key = tempParent.key;
            tempParent.key = z;
            temp = tempParent;
            tempParent = tempParent.parent;
        }

    }

    public int extractMin() {
        if (nodes == null)
            return -1;

        Node temp = nodes, prevTemp = null;
        Node minNode = nodes.getMinNode();

        while (temp.key != minNode.key) {
            prevTemp = temp;
            temp = temp.sibling;
        }

        if (prevTemp == null) {
            nodes = temp.sibling;
        } else {
            prevTemp.sibling = temp.sibling;
        }

        temp = temp.child;
        Node mockNode = temp;

        while (temp != null) {
            temp.parent = null;
            temp = temp.sibling;
        }

        if ((nodes == null) && (mockNode == null)) {
            size = 0;
        } else {
            if ((nodes == null) && (mockNode != null)) {
                nodes = mockNode.reverse(null);
                size = nodes.getSize();
            } else {
                if ((nodes != null) && (mockNode == null)) {
                    size = nodes.getSize();
                } else {
                    unionNodes(mockNode.reverse(null));
                    size = nodes.getSize();
                }
            }
        }

        return minNode.key;
    }


    public void displayHeap() {
        System.out.print("Heap : ");
        displayHeap(nodes);
        System.out.println("\n");
    }

    private void displayHeap(Node r) {
        if (r != null) {
            System.out.print(r.key + " ");
            displayHeap(r.sibling);
            displayHeap(r.child);
        }
    }

}

